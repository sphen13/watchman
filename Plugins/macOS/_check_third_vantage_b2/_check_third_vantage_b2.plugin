#!/bin/bash

# PLUGIN: Third Vantage Middleware Check
# v 1.3

# read prefpane settings & set defaults
pluginName="_check_third_vantage_b2"
settings_plist="/Library/MonitoringClient/PluginSupport/"$pluginName"_settings.plist"
clientSettings="/Library/MonitoringClient/ClientSettings.plist"
munki_plist="/Library/Preferences/ManagedInstalls.plist"
B2DownloadURL='https://f001.backblazeb2.com'
B2AccountID='00104a08df7aead0000000003'
B2ApplicationKey='K001oZTA1k/wAxR35Tb7IZU7t+Ljv0E'
B2ValidDuration=3600
AccessKey='H3NNZLAPH5WF8J8MRTAQ'
SecretKey='eOLtjtpuu8KmlLbpyev15MneRlvzkuegnCRzB77Z'
Region='us-east-1'
S3Endpoint='s3.wasabisys.com'
currentVersion="1.3"

vercomp () {
  if [[ $1 == $2 ]]
  then
      return 0
  fi
  local IFS=.
  local i ver1=($1) ver2=($2)
  # fill empty fields in ver1 with zeros
  for ((i=${#ver1[@]}; i<${#ver2[@]}; i++))
  do
      ver1[i]=0
  done
  for ((i=0; i<${#ver1[@]}; i++))
  do
      if [[ -z ${ver2[i]} ]]
      then
          # fill empty fields in ver2 with zeros
          ver2[i]=0
      fi
      if ((10#${ver1[i]} > 10#${ver2[i]}))
      then
          return 1
      fi
      if ((10#${ver1[i]} < 10#${ver2[i]}))
      then
          return 2
      fi
  done
  return 0
}

if [ ! -f $settings_plist ]; then
	# populate plist with defaults
	defaults write "$settings_plist" PrefPaneVisibility -bool false
	defaults write "$settings_plist" Initially_Disabled -bool false
	chmod 644 "$settings_plist"
fi

if [ -f /usr/local/munki/middleware_b2_s3.py ]; then
	# Middleware installed - lets check and set the settings
  ourB2DownloadURL=`defaults read ${munki_plist} B2DownloadURL 2>/dev/null`
	ourB2AccountID=`defaults read ${munki_plist} B2AccountID 2>/dev/null`
	ourB2ApplicationKey=`defaults read ${munki_plist} B2ApplicationKey 2>/dev/null`
	ourB2ValidDuration=`defaults read ${munki_plist} B2ValidDuration 2>/dev/null`
  ourAccessKey=`defaults read ${munki_plist} AccessKey 2>/dev/null`
	ourSecretKey=`defaults read ${munki_plist} SecretKey 2>/dev/null`
	ourRegion=`defaults read ${munki_plist} Region 2>/dev/null`
	ourS3Endpoint=`defaults read ${munki_plist} S3Endpoint 2>/dev/null`

  if [[ ${ourB2DownloadURL} != ${B2DownloadURL} ]]; then
		echo "Re-setting B2DownloadURL..."
		defaults write ${munki_plist} B2DownloadURL "${B2DownloadURL}"
	fi
	if [[ ${ourB2AccountID} != ${B2AccountID} ]]; then
		echo "Re-setting B2AccountID..."
		defaults write ${munki_plist} B2AccountID "${B2AccountID}"
	fi
	if [[ ${ourB2ApplicationKey} != ${B2ApplicationKey} ]]; then
		echo "Re-setting B2ApplicationKey..."
		defaults write ${munki_plist} B2ApplicationKey "${B2ApplicationKey}"
	fi
	if [[ ${ourB2ValidDuration} != ${B2ValidDuration} ]]; then
		echo "Re-setting B2ValidDuration..."
		defaults write ${munki_plist} B2ValidDuration -int ${B2ValidDuration}
	fi
  if [[ ${ourAccessKey} != ${AccessKey} ]]; then
		echo "Re-setting AccessKey..."
		defaults write ${munki_plist} AccessKey "${ourAccessKey}"
	fi
	if [[ ${ourSecretKey} != ${SecretKey} ]]; then
		echo "Re-setting SecretKey..."
		defaults write ${munki_plist} SecretKey "${ourSecretKey}"
	fi
	if [[ ${ourRegion} != ${Region} ]]; then
		echo "Re-setting Region..."
		defaults write ${munki_plist} Region "${ourRegion}"
	fi
	if [[ ${ourS3Endpoint} != ${S3Endpoint} ]]; then
		echo "Re-setting S3Endpoint..."
		defaults write ${munki_plist} S3Endpoint "${ourS3Endpoint}"
	fi

  osVersion=$(sw_vers -productVersion | cut -d. -f2)

	# lets check what version we have
	installedVersion=$(grep __version__ /usr/local/munki/middleware_b2_s3.py | cut -d "'" -f2 2>/dev/null)
  if [ "$osVersion" -lt "12" ]; then
  	if [[ ${installedVersion} != "1.2b" ]]; then
  	  echo "B2 Middleware ${installedVersion} != "1.2b".  Updating..."
      rm -f /usr/local/munki/middleware*
  	  # write out updated middleware here (EOF)
  		cat <<EOF > /usr/local/munki/middleware_b2_s3.py
"""
Generate authorized backblaze B2 URLs for your munki repo
This module is using munki middleware
https://github.com/munki/munki/wiki/Middleware

I have bundled in s3 handling as well so this can be dual purpose
Credit to: https://github.com/munki/munki/wiki/Middleware

Influenced heavilly by the other great middleware examples!
    - https://github.com/AaronBurchfield/CloudFront-Middleware
    - https://github.com/waderobson/gcs-auth
    ...
"""

import os
import time
import datetime
import json
import base64
import urllib2
import hashlib
import hmac
from string import maketrans
from urlparse import urlparse
from Foundation import CFPreferencesCopyAppValue
from Foundation import CFPreferencesSetValue
from Foundation import CFPreferencesAppSynchronize
from Foundation import kCFPreferencesAnyUser
from Foundation import kCFPreferencesCurrentHost

__version__ = '1.2b'

BUNDLE = 'ManagedInstalls'
METHOD = 'GET'
SERVICE = 's3'


"""
S3
"""

def pref(pref_name):
    """Return a preference. See munkicommon.py for details
    """
    pref_value = CFPreferencesCopyAppValue(pref_name, BUNDLE)
    return pref_value


ACCESS_KEY = pref('AccessKey')
SECRET_KEY = pref('SecretKey')
REGION = pref('Region')
S3_ENDPOINT = pref('S3Endpoint') or 's3.amazonaws.com'


def sign(key, msg):
    return hmac.new(key, msg.encode('utf-8'), hashlib.sha256).digest()


def get_signature_key(key, datestamp, region, service):
    kdate = sign(('AWS4' + key).encode('utf-8'), datestamp)
    kregion = sign(kdate, region)
    kservice = sign(kregion, service)
    ksigning = sign(kservice, 'aws4_request')
    return ksigning


def uri_from_url(url):
    parse = urlparse(url)
    return parse.path


def host_from_url(url):
    parse = urlparse(url)
    return parse.hostname


def s3_auth_headers(url):
    """
    Returns a dict that contains all the required header information.
    Each header is unique to the url requested.
    """
    # Create a date for headers and the credential string
    time_now = datetime.datetime.utcnow()
    amzdate = time_now.strftime('%Y%m%dT%H%M%SZ')
    datestamp = time_now.strftime('%Y%m%d') # Date w/o time, used in credential scope
    uri = uri_from_url(url)
    host = host_from_url(url)
    canonical_uri = uri
    canonical_querystring = ''
    canonical_headers = 'host:{}\nx-amz-date:{}\n'.format(host, amzdate)
    signed_headers = 'host;x-amz-date'
    payload_hash = hashlib.sha256('').hexdigest()
    canonical_request = '{}\n{}\n{}\n{}\n{}\n{}'.format(METHOD,
                                                        canonical_uri,
                                                        canonical_querystring,
                                                        canonical_headers,
                                                        signed_headers,
                                                        payload_hash)

    algorithm = 'AWS4-HMAC-SHA256'
    credential_scope = '{}/{}/{}/aws4_request'.format(datestamp, REGION, SERVICE)
    hashed_request = hashlib.sha256(canonical_request).hexdigest()
    string_to_sign = '{}\n{}\n{}\n{}'.format(algorithm,
                                             amzdate,
                                             credential_scope,
                                             hashed_request)


    signing_key = get_signature_key(SECRET_KEY, datestamp, REGION, SERVICE)
    signature = hmac.new(signing_key, (string_to_sign).encode('utf-8'), hashlib.sha256).hexdigest()

    authorization_header = ("{} Credential={}/{},"
                            " SignedHeaders={}, Signature={}").format(algorithm,
                                                                      ACCESS_KEY,
                                                                      credential_scope,
                                                                      signed_headers,
                                                                      signature)

    headers = {'x-amz-date': amzdate,
               'x-amz-content-sha256': payload_hash,
               'Authorization': authorization_header}
    return headers


"""
B2
"""

def path_and_bucket(url):
    parse = urlparse(url)

    bucket = parse.path.split('/')[1]
    path = parse.path.split(bucket,1)[1]

    return bucket, path

def read_preference(key, bundle):
    """Read a preference key from a preference domain."""
    value = CFPreferencesCopyAppValue(key, bundle)
    return value

def write_preference(key, value, bundle):
    """Write a preference key from a preference domain."""
    CFPreferencesSetValue(key, value, bundle, kCFPreferencesAnyUser, kCFPreferencesCurrentHost)
    CFPreferencesAppSynchronize(bundle)
    return

def authorize_b2(account_id, application_key):
    """Authorize B2 account-level requests"""

    # build auth headers
    id_and_key = account_id + ":" + application_key
    basic_auth_string = 'Basic ' + base64.b64encode(id_and_key)
    headers = { 'Authorization': basic_auth_string }

    # submit api request to b2
    request = urllib2.Request(
        'https://api.backblazeb2.com/b2api/v1/b2_authorize_account',
        headers = headers
        )
    try:
        response = urllib2.urlopen(request)
    except urllib2.HTTPError, e:
        # we got an error - return None
        print ('B2-Middleware: HTTPError ' + str(e.code))
        return None, None, None, None
    except urllib2.URLError, e:
        # we got an error - return None
        print ('B2-Middleware: URLError ' + str(e))
        return None, None, None, None

    response_data = json.loads(response.read())
    response.close()

    # return authorization info
    return response_data['authorizationToken'], response_data['apiUrl'], response_data['downloadUrl'], response_data['allowed']['bucketId']

def b2_bucketName_to_bucketId(account_id, account_token, api_url, bucket_name):
    """Return bucket_id for bucket_name"""

    # build and submit api request to b2
    request = urllib2.Request(
    	'%s/b2api/v1/b2_list_buckets' % api_url,
    	json.dumps({ 'accountId' : account_id }),
    	headers = { 'Authorization': account_token }
    	)
    response = urllib2.urlopen(request)
    response_data = json.loads(response.read())
    response.close()

    # iterate over results to get bucket_id
    for bucket in response_data["buckets"]:
        if bucket["bucketName"] == bucket_name:
            bucket_id = bucket["bucketId"]

    return bucket_id

def b2_download_authorization(account_token, api_url, valid_duration, bucket_id):
    """Return download_authorization_token"""

    # build and submit api request to b2
    request = urllib2.Request(
        '%s/b2api/v1/b2_get_download_authorization' % api_url,
        json.dumps({ 'bucketId' : bucket_id, 'fileNamePrefix' : "", 'validDurationInSeconds' : valid_duration}),
        headers = { 'Authorization': account_token }
        )
    response = urllib2.urlopen(request)
    response_data = json.loads(response.read())
    response.close()

    # return authorization info
    return response_data['authorizationToken']

def b2_url_builder(url):
    """Build our b2 url"""

    # read in our preference keys
    account_id = read_preference('B2AccountID', BUNDLE)
    application_key = read_preference('B2ApplicationKey', BUNDLE)
    valid_duration = read_preference('B2ValidDuration', BUNDLE) or 1800
    valid_duration = int(valid_duration)
    expiration_date = read_preference('B2ExpirationDate', BUNDLE) or datetime.datetime.now()
    download_url = read_preference('B2DownloadURL', BUNDLE)
    download_authorization_token = read_preference('B2DownloadAuthorizationToken', BUNDLE)

    # parse url for b2 file path and bucket name
    bucket_name, path = path_and_bucket(url)

    b2_url = ""
    HEADERS = {}

    # test if our prefs are set
    if account_id and application_key:
        if not (expiration_date > datetime.datetime.now() and download_authorization_token):
            # need to get updated auth token

            # set new expiration date
            expiration_date = datetime.datetime.now() + datetime.timedelta(seconds=valid_duration)

            # get b2 account authorization
            account_token, api_url, download_url, bucket_id = authorize_b2(account_id, application_key)
            if (account_token == None):
                # stop trying to build a url - we dont have authorization
                print "B2-Middleware: Not Authorized."
                return url, None

            if not (bucket_id):
                # we are not restricted to a single bucket, lets get the id we want
                bucket_id = b2_bucketName_to_bucketId(account_id, account_token, api_url, bucket_name)

            # get download authorization token
            download_authorization_token = b2_download_authorization(account_token, api_url, valid_duration, bucket_id)

            if download_authorization_token:
                # We just updated tokens - lets update our prefs
                write_preference("B2ExpirationDate", expiration_date, BUNDLE)
                write_preference("B2DownloadURL", download_url, BUNDLE)
                write_preference("B2DownloadAuthorizationToken", download_authorization_token, BUNDLE)

        if download_authorization_token:
            # We have a valid download_authorization_token at this point, lets continue processing URL.

            b2_url = download_url + "/file/" + bucket_name + path
            HEADERS = { 'Authorization': download_authorization_token }
        else:
            print ("B2-Middleware: API Error")
    else:
        print ("B2-Middleware: No account_id or application_key provided.")

    return b2_url, HEADERS

def process_request_options(options):
    """Return an authorized URL"""

    """Process B2"""
    if '://b2/' in options['url']:
        options['url'], HEADERS = b2_url_builder(options['url'])
        if HEADERS:
            options['additional_headers'].update(HEADERS)
    """Process S3"""
    if S3_ENDPOINT in options['url']:
        headers = s3_auth_headers(options['url'])
        options['additional_headers'].update(headers)

    return options
EOF
    fi
  else
    vercomp ${installedVersion:0:3} ${currentVersion}
    if [[ $? -eq 2  || -z ${installedVersion} ]]; then
      echo "B2 Middleware ${installedVersion} < ${currentVersion}.  Updating..."
      rm -f /usr/local/munki/middleware*
      # write out updated middleware here (EOF)
      cat <<EOF > /usr/local/munki/middleware_b2_s3.py
"""
Generate authorized backblaze B2 URLs for your munki repo
This module is using munki middleware
https://github.com/munki/munki/wiki/Middleware

I have bundled in s3 handling as well so this can be dual purpose
Credit to: https://github.com/munki/munki/wiki/Middleware

Influenced heavilly by the other great middleware examples!
    - https://github.com/AaronBurchfield/CloudFront-Middleware
    - https://github.com/waderobson/gcs-auth
    ...
"""

import datetime
import json
import base64
import hashlib
import hmac
from Foundation import CFPreferencesCopyAppValue
from Foundation import CFPreferencesSetValue
from Foundation import CFPreferencesAppSynchronize
from Foundation import kCFPreferencesAnyUser
from Foundation import kCFPreferencesCurrentHost

try:
    from urlparse import urlparse
    from urllib2 import urlopen, Request, HTTPError, URLError
except ImportError:
    from urllib.parse import urlparse
    from urllib.request import urlopen, Request
    from urllib.error import HTTPError, URLError


__version__ = '1.3'

BUNDLE = 'ManagedInstalls'
METHOD = 'GET'
SERVICE = 's3'
CACert = '/usr/local/munki/godaddy-root.pem'


"""
S3
"""

def pref(pref_name):
    """Return a preference. See munkicommon.py for details
    """
    pref_value = CFPreferencesCopyAppValue(pref_name, BUNDLE)
    return pref_value


ACCESS_KEY = pref('AccessKey')
SECRET_KEY = pref('SecretKey')
REGION = pref('Region')
S3_ENDPOINT = pref('S3Endpoint') or 's3.amazonaws.com'


def sign(key, msg):
    return hmac.new(key, msg.encode('utf-8'), hashlib.sha256).digest()


def get_signature_key(key, datestamp, region, service):
    kdate = sign(('AWS4' + key).encode('utf-8'), datestamp)
    kregion = sign(kdate, region)
    kservice = sign(kregion, service)
    ksigning = sign(kservice, 'aws4_request')
    return ksigning


def uri_from_url(url):
    parse = urlparse(url)
    return parse.path


def host_from_url(url):
    parse = urlparse(url)
    return parse.hostname


def s3_auth_headers(url):
    """
    Returns a dict that contains all the required header information.
    Each header is unique to the url requested.
    """
    # Create a date for headers and the credential string
    time_now = datetime.datetime.utcnow()
    amzdate = time_now.strftime('%Y%m%dT%H%M%SZ')
    datestamp = time_now.strftime('%Y%m%d') # Date w/o time, used in credential scope
    uri = uri_from_url(url)
    host = host_from_url(url)
    canonical_uri = uri
    canonical_querystring = ''
    canonical_headers = 'host:{}\nx-amz-date:{}\n'.format(host, amzdate)
    signed_headers = 'host;x-amz-date'
    payload_hash = hashlib.sha256(''.encode('utf-8')).hexdigest()
    canonical_request = '{}\n{}\n{}\n{}\n{}\n{}'.format(METHOD,
                                                        canonical_uri,
                                                        canonical_querystring,
                                                        canonical_headers,
                                                        signed_headers,
                                                        payload_hash)

    algorithm = 'AWS4-HMAC-SHA256'
    credential_scope = '{}/{}/{}/aws4_request'.format(datestamp, REGION, SERVICE)
    hashed_request = hashlib.sha256(canonical_request.encode('utf-8')).hexdigest()
    string_to_sign = '{}\n{}\n{}\n{}'.format(algorithm,
                                             amzdate,
                                             credential_scope,
                                             hashed_request)


    signing_key = get_signature_key(SECRET_KEY, datestamp, REGION, SERVICE)
    signature = hmac.new(signing_key, (string_to_sign).encode('utf-8'), hashlib.sha256).hexdigest()

    authorization_header = ("{} Credential={}/{},"
                            " SignedHeaders={}, Signature={}").format(algorithm,
                                                                      ACCESS_KEY,
                                                                      credential_scope,
                                                                      signed_headers,
                                                                      signature)

    headers = {'x-amz-date': amzdate,
               'x-amz-content-sha256': payload_hash,
               'Authorization': authorization_header}
    return headers


"""
B2
"""

def path_and_bucket(url):
    parse = urlparse(url)

    bucket = parse.path.split('/')[1]
    path = parse.path.split(bucket, 1)[1]

    return bucket, path

def read_preference(key, bundle):
    """Read a preference key from a preference domain."""
    value = CFPreferencesCopyAppValue(key, bundle)
    return value

def write_preference(key, value, bundle):
    """Write a preference key from a preference domain."""
    CFPreferencesSetValue(key, value, bundle, kCFPreferencesAnyUser, kCFPreferencesCurrentHost)
    CFPreferencesAppSynchronize(bundle)
    return

def authorize_b2(account_id, application_key):
    """Authorize B2 account-level requests"""

    # build auth headers
    id_and_key = account_id + ":" + application_key
    basic_auth_string = 'Basic '.encode('utf-8') + base64.b64encode(id_and_key.encode('utf-8'))
    headers = {'Authorization': basic_auth_string}

    # submit api request to b2
    request = Request(
        'https://api.backblazeb2.com/b2api/v1/b2_authorize_account',
        headers=headers
        )
    try:
        response = urlopen(request, cafile=CACert)
    except HTTPError as e:
        # we got an error - return None
        print(('B2-Middleware: HTTPError ' + str(e.code)))
        return None, None, None, None
    except URLError as e:
        # we got an error - return None
        print(('B2-Middleware: URLError ' + str(e)))
        return None, None, None, None

    response_data = json.loads(response.read())
    response.close()

    # return authorization info
    return response_data['authorizationToken'], response_data['apiUrl'], response_data['downloadUrl'], response_data['allowed']['bucketId']

def b2_bucketName_to_bucketId(account_id, account_token, api_url, bucket_name):
    """Return bucket_id for bucket_name"""

    # build and submit api request to b2
    request = Request(
        '%s/b2api/v1/b2_list_buckets' % api_url,
        json.dumps({'accountId' : account_id}).encode('utf-8'),
        headers={'Authorization': account_token}
        )
    response = urlopen(request, cafile=CACert)
    response_data = json.loads(response.read())
    response.close()

    # iterate over results to get bucket_id
    for bucket in response_data["buckets"]:
        if bucket["bucketName"] == bucket_name:
            bucket_id = bucket["bucketId"]

    return bucket_id

def b2_download_authorization(account_token, api_url, valid_duration, bucket_id):
    """Return download_authorization_token"""

    # build and submit api request to b2
    request = Request(
        '%s/b2api/v1/b2_get_download_authorization' % api_url,
        json.dumps({'bucketId' : bucket_id, 'fileNamePrefix' : "", 'validDurationInSeconds' : valid_duration}).encode('utf-8'),
        headers={'Authorization': account_token}
        )
    response = urlopen(request, cafile=CACert)
    response_data = json.loads(response.read())
    response.close()

    # return authorization info
    return response_data['authorizationToken']

def b2_url_builder(url):
    """Build our b2 url"""

    # read in our preference keys
    account_id = read_preference('B2AccountID', BUNDLE)
    application_key = read_preference('B2ApplicationKey', BUNDLE)
    valid_duration = read_preference('B2ValidDuration', BUNDLE) or 1800
    valid_duration = int(valid_duration)
    expiration_date = read_preference('B2ExpirationDate', BUNDLE) or datetime.datetime.now()
    download_url = read_preference('B2DownloadURL', BUNDLE)
    download_authorization_token = read_preference('B2DownloadAuthorizationToken', BUNDLE)

    # parse url for b2 file path and bucket name
    bucket_name, path = path_and_bucket(url)

    b2_url = ""
    HEADERS = {}

    # test if our prefs are set
    if account_id and application_key:
        if not (expiration_date > datetime.datetime.now() and download_authorization_token):
            # need to get updated auth token

            # set new expiration date
            expiration_date = datetime.datetime.now() + datetime.timedelta(seconds=valid_duration)

            # get b2 account authorization
            account_token, api_url, download_url, bucket_id = authorize_b2(account_id, application_key)
            if (account_token is None):
                # stop trying to build a url - we dont have authorization
                print("B2-Middleware: Not Authorized.")
                return url, None

            if not (bucket_id):
                # we are not restricted to a single bucket, lets get the id we want
                bucket_id = b2_bucketName_to_bucketId(account_id, account_token, api_url, bucket_name)

            # get download authorization token
            download_authorization_token = b2_download_authorization(account_token, api_url, valid_duration, bucket_id)

            if download_authorization_token:
                # We just updated tokens - lets update our prefs
                write_preference("B2ExpirationDate", expiration_date, BUNDLE)
                write_preference("B2DownloadURL", download_url, BUNDLE)
                write_preference("B2DownloadAuthorizationToken", download_authorization_token, BUNDLE)

        if download_authorization_token:
            # We have a valid download_authorization_token at this point, lets continue processing URL.

            b2_url = download_url + "/file/" + bucket_name + path
            HEADERS = {'Authorization': download_authorization_token}
        else:
            print("B2-Middleware: API Error")
    else:
        print("B2-Middleware: No account_id or application_key provided.")

    return b2_url, HEADERS

def process_request_options(options):
    """Return an authorized URL"""

    """Process B2"""
    if '://b2/' in options['url']:
        options['url'], HEADERS = b2_url_builder(options['url'])
        if HEADERS:
            options['additional_headers'].update(HEADERS)
    """Process S3"""
    if S3_ENDPOINT in options['url']:
        headers = s3_auth_headers(options['url'])
        options['additional_headers'].update(headers)

    return options

EOF
      cat <<EOF > /usr/local/munki/godaddy-root.pem
-----BEGIN CERTIFICATE-----
MIIDxTCCAq2gAwIBAgIBADANBgkqhkiG9w0BAQsFADCBgzELMAkGA1UEBhMCVVMx
EDAOBgNVBAgTB0FyaXpvbmExEzARBgNVBAcTClNjb3R0c2RhbGUxGjAYBgNVBAoT
EUdvRGFkZHkuY29tLCBJbmMuMTEwLwYDVQQDEyhHbyBEYWRkeSBSb290IENlcnRp
ZmljYXRlIEF1dGhvcml0eSAtIEcyMB4XDTA5MDkwMTAwMDAwMFoXDTM3MTIzMTIz
NTk1OVowgYMxCzAJBgNVBAYTAlVTMRAwDgYDVQQIEwdBcml6b25hMRMwEQYDVQQH
EwpTY290dHNkYWxlMRowGAYDVQQKExFHb0RhZGR5LmNvbSwgSW5jLjExMC8GA1UE
AxMoR28gRGFkZHkgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkgLSBHMjCCASIw
DQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAL9xYgjx+lk09xvJGKP3gElY6SKD
E6bFIEMBO4Tx5oVJnyfq9oQbTqC023CYxzIBsQU+B07u9PpPL1kwIuerGVZr4oAH
/PMWdYA5UXvl+TW2dE6pjYIT5LY/qQOD+qK+ihVqf94Lw7YZFAXK6sOoBJQ7Rnwy
DfMAZiLIjWltNowRGLfTshxgtDj6AozO091GB94KPutdfMh8+7ArU6SSYmlRJQVh
GkSBjCypQ5Yj36w6gZoOKcUcqeldHraenjAKOc7xiID7S13MMuyFYkMlNAJWJwGR
tDtwKj9useiciAF9n9T521NtYJ2/LOdYq7hfRvzOxBsDPAnrSTFcaUaz4EcCAwEA
AaNCMEAwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYwHQYDVR0OBBYE
FDqahQcQZyi27/a9BUFuIMGU2g/eMA0GCSqGSIb3DQEBCwUAA4IBAQCZ21151fmX
WWcDYfF+OwYxdS2hII5PZYe096acvNjpL9DbWu7PdIxztDhC2gV7+AJ1uP2lsdeu
9tfeE8tTEH6KRtGX+rcuKxGrkLAngPnon1rpN5+r5N9ss4UXnT3ZJE95kTXWXwTr
gIOrmgIttRD02JDHBHNA7XIloKmf7J6raBKZV8aPEjoJpL1E/QYVN8Gb5DKj7Tjo
2GTzLH4U/ALqn83/B2gX2yKQOC16jdFU8WnjXzPKej17CuPKf1855eJ1usV2GDPO
LPAvTK33sefOT6jEm0pUBsV/fdUID+Ic/n4XuKxe9tQWskMJDE32p2u0mYRlynqI
4uJEvlz36hz1
-----END CERTIFICATE-----
EOF
    fi
	fi

else
	exit 25
fi

exit 0
